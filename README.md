- This API simulates a dataflow network similar to that of CSP.
- Please refer to the .png file for UML diagram


1. Channels are essentially buffers with connecting actors acting like producer and consumer. They can only have at most, one producer and one consumer. I chose ArrayBlockingQueue as the specific implementation since it can, to some extent, guarantee fairness so that those blocked data still have an ordering among them. It also allows user to peek () inside, which is useful when implementing actors. I also made the default capacity to 1000 but it can be modified inside the class ArrayBlockingChannel.
2. Actor Interface extends Runnable, so it can be executed. Class AbstractActor has two arrays of Channels, representing respectively input channels and output channels. It also has a helper initialize () which takes in numbers of in and out channels and initialize the aforementioned arrays. Another helper called isComplete () checks if the current actor has all its channels wired up. These two helpers are used by all subclasses.
3. Specific actors are straightforward in what they do. Notably, Input and Output are just identity function, but in order to fully generalize things, they are also connected to Channels on both ends. This means that one has to specifically create a new channel, redirect StdIn/StdOut to this channel, and then connect this channel to Input/Output for things to work. Other notable actors include Constant and Fork. For a Constant Actor to emit a token it must receive a token first. Fork can only fork a piece of data to two channels, meaning that if one wants to fork something three times, one need two fork actors.
4. Class Factory is responsible for creating Actors and Channels and connect them. The helper connectActor () allows connecting two actors with an anonymous Channel. This is more common because the only time one needs to declare a Channel explicitly is to initialize it.
5. Now, the multithreading aspect is handled by an ExecutorSevice with a fixed-sized Threadpool. Actors will be queued up by this Executor. Running Actors will peek () to see it they have all the data they need. If not, they will add themselves to the end of the queue and end their turn until they are scheduled again. An actor that has have the data it needs will fire () and pass the result to its output channels.